/* pitch_detection_v2.cpp */

/** Notes
 * 
 *  -- tensorflow's c++ interface seems to be the path of least resistance, since we're loading
 *     protobuf files generated by tensorflow, but it comes at the cost of build complexity
 *  -- https://stackoverflow.com/questions/56837288/tensorflow-lite-c-api-example-for-inference
 *  -- model is currently installed to /usr/local by cmake, but this doesn't seem right. Investigate.
 *  -- SPICE Model: https://www.tensorflow.org/hub/tutorials/spice
 *  -- "The SPICE model needs as input an audio file at a sampling rate of 16kHz 
 *      and with only one channel (mono).
 **/

#include <cassert>

#include "tensorflow/lite/interpreter.h"
#include "tensorflow/lite/kernels/register.h"
#include "tensorflow/lite/model.h"
#include "tensorflow/lite/tools/gen_op_registration.h"

const float MINIMUM_CONFIDENCE_THRESHOLD = 0.8;

const int SPICE_MODEL_SAMPLE_RATE = 16000;

const int SPICE_MODEL_NUM_CHANNELS = 1;

// the constants below were taken from https://tfhub.dev/google/spice/2

const float PT_OFFSET = 25.58;

const float PT_SLOPE = 63.07;

const float FMIN = 10.0;

const float BINS_PER_OCTAVE = 12.0;

std::unique_ptr<tflite::FlatBufferModel> model { };
std::unique_ptr<tflite::Interpreter> interpreter { };

bool pitch_detection_v2::model_is_loaded()
{
    return model.get() != nullptr;
}

void pitch_detection_v2::load_model()
{
    assert(!pitch_detection_v2::model_is_loaded());
    model = tflite::FlatBufferModel::BuildFromFile("linear.tflite");
    tflite::ops::builtin::BuiltinOpResolver resolver;  
    tflite::InterpreterBuilder(*model.get(), resolver)(&interpreter);
    interpreter->AllocateTensors(); // do i need this?
}

/**
 * Step 1: apply low pass filter (https://cplusplus.com/forum/general/282026/)
 * Step 2: reduce sample rate
 *    - this reduces buffer size, allowing us to overwrite the signal in-place. 
 *    - Iterate through the buffer while overwriting the initial indecies with the decimated signal. 
 *    - The decimated signal will consists of every Nth sample of the original sample,
 *      where N = Desired Sample Rate / Current Sample Rate
 * Step 3: reduce the buffer to a single channel
 * Step 3: use juce::AudioBuffer::setSize to reduce the buffer to a single channel
 *         as well as safely update the size of the now smaller buffer
 **/
void prepareAudioForModel(juce::AudioBuffer<float>& buffer, int sampleRate)
{

    assert(sampleRate > MODEL_INPUT_SAMPLE_RATE);

    void applyLowPassFilter = [&buffer] {
        // TODO
    };

    void downSampleAudio = [&buffer, &sampleRate] {
        int numSamplesAfterDownSampling = SPICE_MODEL_SAMPLE_RATE*buffer.getNumSamples()/sampleRate;

        if (sampleRate > SPICE_MODEL_SAMPLE_RATE) 
        {
            for (int newSignalIndex = 0,
               ; newSignalIndex < numSamplesAfterDownSampling
               ; newSignalIndex += 1;
            ) {
                int oldSignalIndex = static_cast<int>(
                    std::round(newSignalIndex*sampleRate/SPICE_MODEL_SAMPLE_RATE)
                );
                buffer.setSample(newSignalIndex, buffer.getSample(oldSignalIndex));
            }
        }
        buffer.setSize(1 /* num channels */, numSamplesAfterDownSampling);
    };

    applyLowPassFilter();
    downSampleAudio();
}

float* convertModelOutputToFrequencies(float* output, int bufferSize)
{
    float* frequencies[bufferSize];
    for (int index = 0; index < bufferSize; index++)
        frequencies[index] = FMIN * 2.0 ** (1.0 * (ouput[index] * PT_SLOPE + PT_OFFSET) / BINS_PER_OCTAVE);
    return frequencies;
}

float* runModel(juce::AudioBuffer<float>& buffer, int sampleRate)
{
    float* spiceModelInput = interpreter->typed_input_tensor<float>(0);
    for (int sampleIndex = 0; sampleIndex < buffer.getNumSamples(); sampleIndex++) {
        spiceModelInput[sampleIndex] = buffer.getSample(sampleIndex);
    }

    interpreter->Invoke();
    return interpreter->typed_output_tensor<float>(0);
}

float getAverageFrequency(float* frequencies, int numFrequencies) 
{
    float sumOfFrequencies;
    for (int index = 0; index < numFrequencies; index++)
        sumOfFrequencies += frequencies[index];

    return sumOfFrequencies / numFrequencies;
}


float pitch_detection_v2::getFundementalFrequency(juce::AudioBuffer<float>& buffer, int sampleRate)
{
    assert(is_model_loaded());

    if (sampleRate < SPICE_MODEL_SAMPLE_RATE) // audio quality isn't high enough. throw an error.
        assert(false); // TODO: define custom error

    prepareAudioForModel(buffer, sampleRate);
    float* output = runModel(buffer, bufferSize);
    float* frequencies = convertModelOutputToFrequencies(output, buffer.getNumSamples());

    return getAverageFrequency(frequencies);
}